akka {
  loglevel = {{ woken_log_level }}
  # Log level during startup and shutdown
  stdout-loglevel = {{ woken_log_level }}

  log-config-on-start = on
  log-dead-letters = 10
  log-dead-letters-during-shutdown = off

  remote {
    log-sent-messages = off
    log-received-messages = off
    log-remote-lifecycle-events = off

    maximum-payload-bytes = 10000000 bytes

    netty.tcp {
      hostname = ${clustering.ip} # external (logical) hostname
      port = ${clustering.port}   # external (logical) port

{% if woken_docker_network == 'BRIDGE' %}
      # With bridge networking, bind to localhost, then let Docker do the NAT translation
      bind-hostname = 0.0.0.0        # internal (bind) hostname
      bind-port = ${clustering.port} # internal (bind) port
{% else %}
      bind-hostname = 0.0.0.0
      # Network interface will be bound to the woken_akka_port port,
      # and remoting protocol will expect messages sent to the bound port
      bind-port = ""
{% endif %}

      message-frame-size =  10000000b
      send-buffer-size =  10000000b
      receive-buffer-size =  10000000b
      maximum-frame-size = 10000000b
    }
  }

  cluster {

    seed-nodes = [
      "akka.tcp://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}
    ]

    roles = ["woken"]

    role {
      woken.min-nr-of-members = {{ woken_min_nr_of_members }}
      validation.min-nr-of-members = {{ woken_validation_min_nr_of_members }}
      scoring.min-nr-of-members = {{ woken_scoring_min_nr_of_members }}
    }

    client {
      initial-contacts = ["akka.tcp://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}"/system/receptionist"]
    }

  }
}

app {
  clusterSystemName = ${clustering.cluster.name}
  jobServiceName = "job-service"
{% if woken_docker_network == 'BRIDGE' %}
  dockerBridgeNetwork = "{{ woken_docker_bridge_network }}"
{% endif %}
  networkInterface = "{{ woken_http_network_interface }}"
  webServicesPort = {{ woken_http_port }}
  webServicesHttps = off
  disableWorkers = {{ woken_validation_min_nr_of_members == 0 or woken_scoring_min_nr_of_members == 0 }}

  master.router {
    actors {
      mining.limit = {{ woken_mining_limit }}
      experiment.limit = {{ woken_experiment_limit }}
    }
  }

  basicAuth {
    user = "{{ woken_basicauth_username }}"
    password = "{{ woken_basicauth_password }}"
  }
}

jobs {
  node = "{{ inventory_hostname }}"
  owner = "admin@mip.chuv.ch"
  chronosServerUrl = "{{ internal_chronos_url }}"
{% if woken_role == 'mip_federation' %}
{% else %}
  # TODO: connection to feature table should only be used for worker nodes
{% endif %}
  featuresDb = "{{ woken_features_db_name }}"
  featuresTable = "{{ woken_features_table }}"
  resultDb = "{{ woken_result_db_name }}"
  metaDb = "{{ woken_metadata_db_name }}"
}

db {
  {{ woken_result_db_name }} {
    jdbc_driver = "{{ woken_result_db_jdbc_driver }}"
    jdbc_url = "{{ woken_result_db_jdbc_url }}"
    host = "{{ woken_result_db_host }}"
    port = {{ woken_result_db_port }}
    user = "{{ woken_result_db_user }}"
    password = "{{ woken_result_db_password }}"
  }

  {{ woken_features_db_name }} {
    jdbc_driver = "{{ woken_features_db_jdbc_driver }}"
    jdbc_url = "{{ woken_features_db_jdbc_url }}"
    host = "{{ woken_features_db_host }}"
    port = "{{ woken_features_db_port }}"
    user = "{{ woken_features_db_user }}"
    password = "{{ woken_features_db_password }}"
  }

  {{ woken_metadata_db_name }} {
    jdbc_driver = "{{ woken_metadata_db_jdbc_driver }}"
    jdbc_url = "{{ woken_metadata_db_jdbc_url }}"
    host = "{{ woken_metadata_db_host }}"
    port = {{ woken_metadata_db_port }}
    user = "{{ woken_metadata_db_user }}"
    password = "{{ woken_metadata_db_password }}"
  }

}

datasets {
{% for fn in woken_datasets %}
  {{ fn.name }} {
    label = "{{ fn.label }}"
    description = "{{ fn.description }}"
{% if fn.tables is defined %}
    tables = {{ fn.tables | to_json }}
{% endif %}
    anonymisationLevel = "{{ fn.anonymisationLevel }}"
{% if fn.location is defined %}
    location {
      url = "{fn.location.url}"
      basicAuth {
        user = "{fn.location.basicAuth.user}"
        password = "{fn.location.basicAuth.password}"
      }
{% endif %}
  }
{% endfor %}
}

algorithms {
{% for fn in woken_algorithms %}
  {{ fn.name }} = {
    dockerImage = "{{ fn.docker_image }}"
    predictive = {{ fn.predictive | lower }}
  }
{% endfor %}
}

